\section{CutMax a new approximate mathing algorithm}
\label{section:our}
We now describe several algorithms that heavily based on \emph{semi-local sa} and it's underlying algebraic structure.

The first algorithm \ref{alg:appximateMatchingGreedy} refers to following constraint.
There should be found all non-intersected clones $\tau_{i}$ of pattern $p$ from text $t$ that has the highest similarity score on the uncovered part of the text $t$ and $\alpha \geq |tau_{i}| \geq \beta$  i.e algorithm should perform greedy choice at each step with length constraint on $\tau_{i}$.
This is a more intuitive approach i.e like looking for the most similar substring every time with length at least $l$ and at most $r$. 
\red{Formally}:
\begin{equation}
   \tau_{i} =  \argmax_{l,r \in (t \cap (\cup_{j=1}^{i-1} \tau_{j}),l<r, \alpha \leq |t_{l,r}| \leq \beta ,t_{l,r} \cap (\cup_{j=1}^{i-1} \tau_{j}) = \emptyset } sa(t_{l,r}, p)
\end{equation}

The algorithm proceeds as follows.
First, the \emph{semi-local sa} problem is solved for given pattern $p$ and text $t$ (Line 1).
Then, solution for string-substring subproblem is queried from it (Line 2).
Further the diagonal slice of width $r-l$ that corresponds to
scores of substrings of size in $[l:r]$ is croped in order to get staircase anti Monge Matrix (Line 3).
Upon starircase matrix $-M_{staircase}$ is built full monge Matrix $M$. 
Then, \emph{rmq} data structure is built  for perfoming range minimum queries on $M$.

Second, algorthm make recursive call to subroutine $greedy$.
The $greedy$ routine perfoms greedy choice of $\tau_{i}$  with maximal alignment within the current uncovered part of the text $t_{i,j}$ with legnth boundaries for $\tau_{i}$ in $[l:r]$.
More precisely, it refers to searching maximum value with corresponding position (row and column) in matrix $M$ within  $t_{i,j}$ (starting at $i$th position and ending at $j$th position of text $t$.
It is solved via range queries.
When detected $interval$ has alignment score less then threshold it means that no clones of pattern $p$ are presented in this part of text $t_{i,j}$, and further processing should be skipped.
Otherwise, the founded clone is added to final result and the current part of the text splits on two smaller parts and processed in the same way.
Finally, the algorithm outputs a set of the non-intersected intervals of clones of pattern p in text t.


\begin{algorithm}[H]
\caption{Greedy subroutine}
\label{alg:rec}
Input: $rmq2D$--- range maximum query data structure for perfoming range queries on monge matrix $M$, $h$ --- theshold value, $i,j$ --- start and end positions of current text $t_{i,j}$, $l,r$--- length boundaries for detected intervals \\
Output: Set of non-intersected intervals from $t_{i,j}$\\
Pseudocode:\\
$greedy(rmq2D,h, i, j, t_{i,j},l,r ):$

\begin{algorithmic}[1]
\STATE{$interval = rmq2D.query(i,j,i,j)$}
\STATE{$result = \emptyset$}
\IF{ $interval.score < h $}
\RETURN $result$
\ENDIF
\IF{ $interval.i - i \geq l $}
\STATE{$cl = greedy(rmq2D,h,i,interval.i,t_{i,interval.i},l,r)$}
\STATE{$result.add(cl)$}
\ENDIF
\IF{$j - interval.j \geq l$}
\STATE{$cl = greedy(rmq2D,h,j,interval.j,t_{j,interval.j},l,r)$}
\STATE{$result.add(cl)$}
\ENDIF
\RETURN $result$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{GREEDY-PATTERN BASED NEAR DUPLICATE
SEARCH ALGORITHM}
\label{alg:appximateMatchingGreedy}
Input: pattern $p$ and text $t$, theshold value $h$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$\\
Pseudocode:\\
$GreedyMathing(M,h,t)$
\begin{algorithmic}[1]
\STATE{$sa = semilocalsa(a,b)$}
\STATE{$H = sa.getStringSubstringMatrix()$}
\STATE{$M_{staircase} = getStaircaseMatrix(H,l,r)$}
\STATE{$M = builtMongeMatrix(-M_{staircase})$}
\STATE{$rmq2D = buildRMQStructure(M) $}
\STATE{$result = greedy(rmq2D,h,0,|t|,t,l,r)$}
\RETURN $result$
\end{algorithmic}
\end{algorithm}


\begin{theorem}
Algorithm \ref{alg:appximateMatchingGreedy} could  be solved in
$O(max(|t||p||v|,\frac{|t| \log^2 |t|}{\log \log |t|} ))$ time and $O(|t|v \log )$ space.
$\max ( O(|p| * |t| * v), O(|t| * \log |t|))$ time with $ O(|t| \log |t|)$ space when $|p|<|t|$ where $p$ is pattern, $t$ is text and $v$ is denominator of normalized mismatch score for semi-local sequence alignment
$w_{normalized} = (1,\frac{\mu}{v},0)$.
\end{theorem}

The \emph{semi-local sa} requires $O(|t||p||v|)$ time \ref{.}.
We will store solution of \emph{semi-local sa} implicitly via sophisticated data structure from \cite{}.
We have $O(|t|v+|p|v) = O(|t|v)$ points to preprocess.
Then the data stucture of size $O(|t||v|)$ can be built in
$O(v|t|  \sqrt{\log(|t|v))}$ time to anwer orthogonal range queries in $O(\frac{\log (v|t|)}{\log \log (v|t|)})$ time.
Thus, any element of matrix can be queried in
$O(\frac{\log (v|t|)}{\log \log (v|t|)})$.   

Lines (2-3) is just an slice of indices and  made inplace.
Lines (4-5) corresponds to THREOREMABOUTSTAIRVASE and requires 
where $q$--- time access of matrix element.
We will use these data structure with the difference that we return indexed of  minimum element along with element itself. 
Then the data structure of size $O(|t|)$ can be built in time $O(|t|\log |t|) * O(\frac{\log (v|t|)}{\log \log (v|t|)}))=
O(\frac{|t|\log |t| \log (v|t|)}{\log \log (v|t|)})
$ to answer
rmq queries in $O(\log \log |t|)*O(\frac{\log (v|t|)}{\log \log (v|t|)}))=O(\frac{\log \log |t| * \log (v|t|)}{\log \log (v|t|))})$.


The first phase of algorithm requires $O(|p| * |t| * v)$ with $O(|t| * v)$ additional space for stroring monge matrix implicitly.
We denote this matrix, specifically it's lower-left quadrant that refers to
string-substring solution as $M$ with size $|t| \times |t|$.


  Theorema 3.4
First, note that 

Building structure for rmq queries for staircase matrix requires 
Theorem 5.8. Given an n $\times$ n partial Monge matrix M, a data structure of size O(n) can be con-
structed in O(n logn) time to answer submatrix maximum queries in O(log logn) time.
   

\red{Proof it}
\begin{displaymath}
    D = \diag(d_1,\dots,d_n)
  \end{displaymath}


\begin{corollary}
Algorithm \ref{alg:appximateMatchingGreedy} could  be solved in 
$\max ( O(|p| * |t|), O(|t| * \log |t|))$ when $v = O(1)$.

\end{corollary}




The second algorithm \ref{alg:appximateMatchingMax} uses a less sophisticated approach and a more lightweight one but found fewer duplicates of pattern $p$(see example \ref{}).
The algorithm also follows a greedy approach but instead of looking at the uncovered part of text $t$ at each step it looks at the text $t$ and chooses the first available substring with the highest score that doesn't intersect with already taken substrings.
More formally, it approximates algorithm \ref{alg:appximateMatchingGreedy}.

\paragraph{Algorithm description}
First, the \emph{semi-local sa} problem is solved (Line 1).
Then we solve \emph{complete approximate matching problem} (Line 3) i.e
for each prefix of text $t$ we find the shortest suffix that has the highest similarity score with pattern $p$ (Line 3):
\begin{equation}
    a[j] = \max _{i \in 0 ..j} sa(p,t[i,j]), j \in 0..|t|
\end{equation}

Further, we remove suffixes whose similarity is below the given threshold $h$ (Line 4).
Then remaining suffixes are sorted in descending order (Line 5) and the interval tree is built upon them (Lines 7-11).
The building process comprises from checking that current substring $candidate$ not intersected with already added substrings to $tree$ and adding it to $tree$.
Finally, algorithm output set of non-intersected substrings (clones) of pattern $p$ in text $t$.


\begin{algorithm}[H]
\caption{Greedy approximate}
\label{alg:appximateMatchingMax}
Input: pattern $p$, text $t$, theshold value $h$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$\\
Pseudocode:
\begin{algorithmic}[1]

\STATE{$sa = semilocalsa(p,t)$}
\STATE{$matrix = sa.getStringSubstringMatrix() $}
\STATE{$colmax = smawk(matrix) $}
\STATE{$colmax = colmax.filter(it.score >= h$)}
\STATE{$colmax = colmax.sortedByDescending(it.score)$}
\STATE{$tree = buildIntervalTree()$}
\FOR{$candidate \in colmax$}
\IF{$candidate \cap tree = \emptyset $}
\STATE{$tree.add(candidate)$}
\ENDIF
\ENDFOR
\STATE{$result = tree.toList()$}
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\begin{theorem}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in
$\max (O(|p|*|t|*|v|), O(|t|* \log^2 |t| v))$ time with $O(|t| * v * \log {|t| * v })$ space when $|p|<|t|$ where $p$ is pattern, $t$ is text and $v$ is denominator of normalized mismatch score for semi-local sequence alignment
$w_{normalized} = (1,\frac{\mu}{v},0)$ assuming we are storing solution matrix implicitly.

\emph{First phase}.
As shown in section \ref{section:preliminaries} the time complexity 
of solving $semi-local sa$ is $O(|p|*|t|*|v|)$.
The space complexity of storing monge matrix of semi-local solution is
$O(|t| * v * \log {|t| * v })$ at most due to fact that $v-subbistochastic matrix$ has at most $v$ non-zeros in each row and upon these $v * |t|$ points we 
build two dimensional range tree data structure with $|t| * v * \log {|t| * v }$ nodes that have report range sum queries in $O(\log^2 |t| v)$ time.

\emph{Second phase}.
$SMAWK$ algorithm requires $O(|t|*q)$ time where $q$ stands for time complexity of  random access of monge matrix.
Thus, the  total time complexity of line 3 is $O(|t|* \log^2 |t| v)$ .
Filtering and sorting have at most $O(|t|)$ and $O(|t|*log|t|)$ time complexity.
In Line 6 simple intialization of interval tree is perfomed that requires $O(1)$.

\emph{Third phase}
$colmax$ array has as worst case $O(|t|)$ elements when filtering does not eliminate any substrings.
Thus, adding to interval tree (both operation at most require $O(\log |t|)$ time) as well as intersection in (Lines 8-9) will be perfomed at most $O(|t|)$.
Thus, the total complexity of last phase is $O(|t|* \log t)$.

As we see, the third  phase is dominated by the second phase in terms of running time and second phase is dominated by the space complexity of third phase. 
Thereby,the total time and space complexity is $\max (O(|p|*|t|*|v|), O(|t|* \log^2 |t| v))$ and $O(|t| * v * \log {|t| * v })$  respectively.
 

\end{theorem}


\begin{corollary}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in 
$\max ( O(|p| * |t|), O(|t| * \log |t|))$ when $v = O(1)$.

When $v = O(1)$ we will use simple range tree for orthogonal range queries with  $O(log|t|)$ query time.

\end{corollary}

\begin{corollary}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in 
$O(|p| * |t|)$.

When amount of clones is relatively small and threshold value is set high  then after filtering out $t$ intervals (Line 4) sorting is perfomed on s small set of elements.
Thus, this part is dominated by calculating semi-local sa solution.
\end{corollary}







  

%Given some rope $t$ and small rope $p$ you need to make cuts to form small ropes $t_{i_{1},j_{1}},t_{i_{2},j_{2}}...,t_{i_{k},j_{k}}$ for some $k$ and select some of them that very similiar to  rope $p$ i.e have high similiarity score.
%For that, we would consider constarint that each select of $t_{k} = t_{i_{k},j_{k}}$ should be made greedy i.e   $t_{k}$ it has the highest similiarity score against $p$ over all possible choices of      

 
%The following interpretation can be applied.
%Given text interval $t_{i}$   
