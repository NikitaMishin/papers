\section{CutMax a new approximate mathing algorithm}
\label{section:our}
\red{Say about extension???}
We now describe several algorithms that heavily based on \emph{semi-local sa} and it's underlying algebraic structure.

The first algorithm \ref{alg:appximateMatchingGreedy} refers to following constraint.
There should be found all non-intersected clones $\tau_{i}$ of pattern $p$ from text $t$ that has the highest similarity score on the uncovered part of the text $t$ and $\alpha \geq |tau_{i}| \geq \beta$  i.e algorithm should perform greedy choice at each step with length constraint on $\tau_{i}$.
This is a more intuitive approach i.e like looking for the most similar substring every time with length at least $l$ and at most $r$. 
\red{Formally}:
\begin{equation}
   \tau_{i} =  \argmax_{l,r \in (t \cap (\cup_{j=1}^{i-1} \tau_{j}),l<r, \alpha \leq |t_{l,r}| \leq \beta ,t_{l,r} \cap (\cup_{j=1}^{i-1} \tau_{j}) = \emptyset } sa(t_{l,r}, p)
\end{equation}

The algorithm proceeds as follows.

First, the \emph{semi-local sa} problem is solved for given pattern $p$ and text $t$ (Line 1).
Then, the solution for the string-substring subproblem is queried from it (Lines 2-3).
Further the diagonal slice of width $r-l$ that corresponds to
scores of substrings of size in $[l:r]$ is cropped to get partial Monge Matrix (Line 3) (see fig).
Upon partial matrix $M_{partial}$, the full Monge Matrix $M$ is built to build \emph{rmq2D} data structure  for performing range minimum queries on $M$ by Theorem \ref{partialTheorem}.

Second, algorithm makes recursive call to subroutine $greedy$(algorithm \ref{alg:rec}).
The $greedy$ routine performs greedy choice of $\tau_{i}$  with maximal alignment within the current uncovered part of the text $t_{i,j}$ with length boundaries for $\tau_{i}$ in $[l:r]$.
More precisely, it refers to searching maximum value with corresponding position (row and column) in matrix $M$ within  $t_{i,j}$ (starting at $i$th position and ending at $j$th position of text $t$.
It is solved via range queries.
When detected $interval$ has alignment score less then threshold it means that no clones of pattern $p$ are presented in this part of text $t_{i,j}$, and further processing should be skipped.
Otherwise, the founded clone is added to the final result and the current part of the text splits into two smaller parts and processed in the same way.
Finally, the algorithm outputs a set of the non-intersected intervals of clones of pattern $p$ in text $t$.


\begin{algorithm}[H]
\caption{Greedy subroutine}
\label{alg:rec}
Input: $rmq2D$--- range maximum query data structure for performing range queries on Monge matrix $M$, $h$ --- threshold value, $i,j$ --- start and end positions of current text $t_{i,j}$, $l,r$--- length boundaries for detected intervals \\
Output: Set of non-intersected intervals from $t_{i,j}$\\
Pseudocode:\\
$greedy(rmq2D,h, i, j, t_{i,j},l,r ):$

\begin{algorithmic}[1]
\STATE{$interval = rmq2D.query(i,j,i,j)$}
\STATE{$result = \emptyset$}
\IF{ $interval.score < h $}
\RETURN $result$
\ENDIF
\IF{ $interval.i - i \geq l $}
\STATE{$cl = greedy(rmq2D,h,i,interval.i,t_{i,interval.i},l,r)$}
\STATE{$result.add(cl)$}
\ENDIF
\IF{$j - interval.j \geq l$}
\STATE{$cl = greedy(rmq2D,h,j,interval.j,t_{j,interval.j},l,r)$}
\STATE{$result.add(cl)$}
\ENDIF
\RETURN $result$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
\caption{GREEDY-PATTERN BASED NEAR DUPLICATE
SEARCH ALGORITHM}
\label{alg:appximateMatchingGreedy}
Input: pattern $p$ and text $t$, threshold value $h$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$\\
Pseudocode:\\
$GreedyMathing(M,h,t)$
\begin{algorithmic}[1]
\STATE{$sa = semilocalsa(a,b)$}
\COMMENT{1st phase}
\STATE{$H = sa.getAssociatedMatrix()$}
\STATE{$H^{str-sub} = H.stringSubstringMatrix()$}
\STATE{$M_{partial} = -getPartialMatrix(H^{str-sub},l,r)$}
\COMMENT{2nd phase}
\STATE{$M = builtMongeMatrix(M_{partial})$}

\STATE{$rmq2D = buildRMQStructure(M) $}
\STATE{$result = greedy(rmq2D,h,0,|t|,t,l,r)$}
\COMMENT{3rd phase}
\RETURN $result$
\end{algorithmic}
\end{algorithm}


\begin{theorem}
Algorithm \ref{alg:appximateMatchingGreedy} could  be solved in
$O(max(|t||p|,\frac{|t| \log^2 |t|}{\log \log |t|} ))$ time and $O(|t| )$ space when $|p|<|t|$ where $p$ is pattern, $t$, is text and $v=O(1)$ is denominator of normalized mismatch score for semi-local sequence alignment
$w_{normalized} = (1,\frac{\mu}{v},0)$.
\end{theorem}
Note that $|p|<|t|$ and $v=O(1)$.
For simplicity let $v=1$ (same true for other $v=O(1)$).

\emph{First phase}. 
We need to solve $semi-local lcs$ because $v=1$.
It could be solved implicitly via algorithm from \cite{.}
in $O(|t||p|)$ with $O(|t|)$ additional space when $O(|p|<|t|)$
Note that we only interesting in string-substring submatrix $H^{str-sub}_{p,t}$ of size $|t| \times |t|$.
Upon associated permutation matrix with $H^{str-sub}_{p,t}$ anti-Monge matrix ( Theorem \ref{decomposition})  we build data structure
of size $O(|t|)$ in $O(|t|\sqrt{\log(|t|))}$ time to 
perform  orthogonal range queries in $O(\frac{\log (|t|)}{\log \log (|t|)})$ time.

Thus, the overall time and space complexity of first phase 
is $max(O(|t|  \sqrt{\log(|t|))},O(|p||t|))$ and
$O(|t|)$ respectively.

\emph{Second phase}.
In string-substring matrix $H^{str-sub}_{p,t}$ we only interesting in diagonal of length $r-l$ that refers to all substrings of text $t$ with length in $[l:r]$ interval. 
If we apply to  $H^{str-sub}_{p,t}$ inverse operation and cut this diagonal we will have partial Monge matrix $M_{partial}$.
Then we apply theorem  \ref{partialTheorem} to build 
\emph{rmq2D} data structure to perform minimum range queries.
Note that we have non-constant access to the element in $M_{partial}$ and we will return not the element itself but also associated indices of it.
Thus, the data structure of size 
$O(|t|)$
 can be built in $O(|t| \log |t|)* O(\frac{\log (|t|)}{\log \log (|t|)}) = O(\frac{|t|\log^2 |t|}{\log \log (|t|)}) $ time
to perform range minimum queries in $O(\log \log (|t|))*O(\frac{\log (|t|)}{\log \log (|t|)})=O(\log |t|)$ time.

Then, overall time and space complexity of second phase is 
$O(|t| \log^2 |t|)$ and
$O(|t|)$
respectively.


\emph{Third phase}

To analyze the third phase we need to look at the recursive algorithm \ref{alg:rec}.
Note that at the worst case we will have $O(|t|)$ nodes while proceeded recursion due to fact that at the worst case on each node we will detect interval of size 1.
Such non-intersected intervals will be at most $t$.
Thus, the total amount of calls to $query$ operation will be at most 
$O(|t|)$.
The query operation requires $O(\log |t|)$ as shown in the previous phase.
Thus, the total running time and space complexity of third phase is 
$O(|t| |\log t|)$ and $O(|t|)$  

Then, overall algorithm running time and space complexity is as claimed when $v=O(1)$ and $|p|<|t|$.




The second algorithm \ref{alg:appximateMatchingMax} uses a less sophisticated approach and a more lightweight one but found fewer duplicates of pattern $p$(see example \ref{}).
The algorithm also follows a greedy approach but instead of looking at the uncovered part of text $t$ at each step it looks at the text $t$ and chooses the first available substring with the highest score that doesn't intersect with already taken substrings.
More formally, it approximates algorithm \ref{alg:appximateMatchingGreedy}.

\paragraph{Algorithm description}
First, the \emph{semi-local sa} problem is solved (Line 1).
Then we solve \emph{complete approximate matching problem} (Line 3) i.e
for each prefix of text $t$ we find the shortest suffix that has the highest similarity score with pattern $p$ (Line 3):
\begin{equation}
    a[j] = \max _{i \in 0 ..j} sa(p,t[i,j]), j \in 0..|t|
\end{equation}

Further, we remove suffixes whose similarity is below the given threshold $h$ (Line 4).
Then remaining suffixes are sorted in descending order (Line 5) and the interval tree is built upon them (Lines 7-11).
The building process comprises from checking that current substring $candidate$ not intersected with already added substrings to $tree$ and adding it to $tree$.
Finally, algorithm output set of non-intersected substrings (clones) of pattern $p$ in text $t$.


\begin{algorithm}[H]
\caption{Greedy approximate}
\label{alg:appximateMatchingMax}
Input: pattern $p$, text $t$, theshold value $h$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$\\
Pseudocode:
\begin{algorithmic}[1]

\STATE{$sa = semilocalsa(p,t)$}
\STATE{$matrix = sa.getStringSubstringMatrix() $}
\STATE{$colmax = smawk(matrix) $}
\STATE{$colmax = colmax.filter(it.score >= h$)}
\STATE{$colmax = colmax.sortedByDescending(it.score)$}
\STATE{$tree = buildIntervalTree()$}
\FOR{$candidate \in colmax$}
\IF{$candidate \cap tree = \emptyset $}
\STATE{$tree.add(candidate)$}
\ENDIF
\ENDFOR
\STATE{$result = tree.toList()$}
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\begin{theorem}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in
$\max (O(|p|*|t|*|v|), O(|t|* \log^2 |t| v))$ time with $O(|t| * v * \log {|t| * v })$ space when $|p|<|t|$ where $p$ is pattern, $t$ is text and $v$ is denominator of normalized mismatch score for semi-local sequence alignment
$w_{normalized} = (1,\frac{\mu}{v},0)$ assuming we are storing solution matrix implicitly.

\emph{First phase}.
As shown in section \ref{section:preliminaries} the time complexity 
of solving $semi-local sa$ is $O(|p|*|t|*|v|)$.
The space complexity of storing monge matrix of semi-local solution is
$O(|t| * v * \log {|t| * v })$ at most due to fact that $v-subbistochastic matrix$ has at most $v$ non-zeros in each row and upon these $v * |t|$ points we 
build two dimensional range tree data structure with $|t| * v * \log {|t| * v }$ nodes that have report range sum queries in $O(\log^2 |t| v)$ time.

\emph{Second phase}.
$SMAWK$ algorithm requires $O(|t|*q)$ time where $q$ stands for time complexity of  random access of monge matrix.
Thus, the  total time complexity of line 3 is $O(|t|* \log^2 |t| v)$ .
Filtering and sorting have at most $O(|t|)$ and $O(|t|*log|t|)$ time complexity.
In Line 6 simple intialization of interval tree is perfomed that requires $O(1)$.

\emph{Third phase}
$colmax$ array has as worst case $O(|t|)$ elements when filtering does not eliminate any substrings.
Thus, adding to interval tree (both operation at most require $O(\log |t|)$ time) as well as intersection in (Lines 8-9) will be perfomed at most $O(|t|)$.
Thus, the total complexity of last phase is $O(|t|* \log t)$.

As we see, the third  phase is dominated by the second phase in terms of running time and second phase is dominated by the space complexity of third phase. 
Thereby,the total time and space complexity is $\max (O(|p|*|t|*|v|), O(|t|* \log^2 |t| v))$ and $O(|t| * v * \log {|t| * v })$  respectively.
 

\end{theorem}


\begin{corollary}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in 
$\max ( O(|p| * |t|), O(|t| * \log |t|))$ when $v = O(1)$.

When $v = O(1)$ we will use simple range tree for orthogonal range queries with  $O(log|t|)$ query time.

\end{corollary}

\begin{corollary}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in 
$O(|p| * |t|)$.

When amount of clones is relatively small and threshold value is set high  then after filtering out $t$ intervals (Line 4) sorting is perfomed on s small set of elements.
Thus, this part is dominated by calculating semi-local sa solution.
\end{corollary}







  

%Given some rope $t$ and small rope $p$ you need to make cuts to form small ropes $t_{i_{1},j_{1}},t_{i_{2},j_{2}}...,t_{i_{k},j_{k}}$ for some $k$ and select some of them that very similiar to  rope $p$ i.e have high similiarity score.
%For that, we would consider constarint that each select of $t_{k} = t_{i_{k},j_{k}}$ should be made greedy i.e   $t_{k}$ it has the highest similiarity score against $p$ over all possible choices of      

 
%The following interpretation can be applied.
%Given text interval $t_{i}$   
