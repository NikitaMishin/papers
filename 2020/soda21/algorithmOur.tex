\section{CutMax a new approximate mathing algorithm}
\label{section:our}
We now describe several algorithms that heavily based on semi-local lcs and it's underlying algebraic structure.

The first algorithm \ref{alg:appximateMatchingGreedy} refers to following constraint.
There should be found all non-intersected clones $\tau_{i}$ of pattern $p$ from text $t$ that has the highest similarity score on the uncovered part of the text $t$ and $l \geq |tau_{i}| \geq r$  i.e algorithm should perform greedy choice at each step with length constraint.
This is a more intuitive approach i.e like looking for the most similar one every time that have enough. 

The algorithm proceeds as follows.
First, semi-local sa problem is solved (Line 1).
Then upon string-substring submatrix of semi-local sa solution is built data structure for performing range queries on it (Lines 2-3).
$IntervalsToSearch$ is structure that holds text intervals where search should be perfomed.
Lines 7-21 corresponds to seaching $interval$ with maximal alignment within the current uncovered part of the text $t_{i,j}$.
More precisely, it refers to searching maximum value with corresponding position (row and column) in submatrix of string-substring $matrix$ within  $t_{i,j}$ (starting at $i$th position and ending at $j$th position of text $t$.
 It is solved via range queries (Line 9).
When detected $interval$ has alignment score less then threshold it means that no clones of pattern $p$ are presented in this part of text $t_{i,j}$, and further processing should be skipped (Line 19).
Otherwise, the founded clone is added to final result and the current part of the text splits on two smaller parts and processed in the same way (Lines 13, 15).
Finally, the algorithm outputs a set of the non-intersected intervals of clones of pattern p in text t.

%Lines 7-21 basically  iterative version of recursion where at each level of recursion amount of quesries is doubles at worst case.
%The total amount of  nodes at each level is following.
%At the bottom level of recursion is $t$ nodes, next level is $t/2$, ith level is $t/2_{i}$.
%Thus, the overall amoount of nodes is $t+\frac{t}{2}+\frac{t}{4}+....1 = t*(1 + \frac{1}{2} + \frac{1}{4}+\frac{1}{2^{i}}) $ = sum.
%As mentioned above complexity of query is O().
%This time complexity of Lines 7-21 is O()....

\begin{algorithm}[H]
\caption{GREEDY-PATTERN BASED NEAR DUPLICATE
SEARCH ALGORITHM VIA SEMI-LOCAL SA}
\label{alg:appximateMatchingGreedy}
Input: pattern $p$, text $t$, theshold value $h$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$\\
Pseudocode:
\begin{algorithmic}[1]
\STATE{$sa = semilocalsa(p,t)$}
\STATE{$matrix = sa.getStringSubstringMatrix() $}
\STATE{$rmQ2D = buildRMQStructure(matrix) $}
\STATE{$intervalsToSearch = \emptyset $}
\STATE{$intervalsToSearch.add((0,|t|)) $}
\STATE{$result = \emptyset$}
\WHILE{$intervalsToSearch.isNotEmpty()$}
\STATE{$i,j = intervalsToSearch.pop()$ }
\STATE{ $interval = rmQ2D.query(i, j, i, j) $ }
   \IF{ $interval.score \geq h $}
   \STATE{ $result.add(interval)$}
   	\IF{$interval.startInclusive - i  \geq 1$}
   	\STATE{$intervalsToSearch.add((i, interval.startInclusive))$}
   	\ENDIF
   	\IF{$j - interval.endExclusive   \geq 1$}
   	\STATE{$intervalsToSearch.add((interval.endExclusive, j))$}
   	\ENDIF
   	
   \ELSE 
   \STATE $continue$ 
   \ENDIF
\ENDWHILE
\RETURN $result$

\end{algorithmic}
\end{algorithm}


The second algorithm \ref{alg:appximateMatchingMax} uses a less sophisticated approach and a more lightweight one but found fewer duplicates of pattern $p$(see example \ref{}).
The algorithm also follows a greedy approach but instead of looking at the uncovered part of text $t$ at each step it looks at the text $t$ and chooses the first available substring with the highest score that doesn't intersect with already taken substrings.
More formally, it approximates algorithm \ref{alg:appximateMatchingGreedy}.

\paragraph{Algorithm description}
First, the \emph{semi-local sa} problem is solved (Line 1).
Then we solve \emph{complete approximate matching problem} (Line 3) i.e
for each prefix of text $t$ we find the shortest suffix that has the highest similarity score with pattern $p$ (Line 3):
\begin{equation}
    a[j] = \max _{i \in 0 ..j} sa(p,t[i,j]), j \in 0..|t|
\end{equation}

Further, we remove suffixes whose similarity is below the given threshold $h$ (Line 4).
Then remaining suffixes are sorted in descending order (Line 5) and the interval tree is built upon them (Lines 7-11).
The building process comprises from checking that current substring $candidate$ not intersected with already added substrings to $tree$ and adding it to $tree$.
Finally, algorithm output set of non-intersected substrings (clones) of pattern $p$ in text $t$.


\begin{algorithm}[H]
\caption{Greedy approximate}
\label{alg:appximateMatchingMax}
Input: pattern $p$, text $t$, theshold value $h$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$\\
Pseudocode:
\begin{algorithmic}[1]

\STATE{$sa = semilocalsa(p,t)$}
\STATE{$matrix = sa.getStringSubstringMatrix() $}
\STATE{$colmax = smawk(matrix) $}
\STATE{$colmax = colmax.filter(it.score >= h$)}
\STATE{$colmax = colmax.sortedByDescending(it.score)$}
\STATE{$tree = buildIntervalTree()$}
\FOR{$candidate \in colmax$}
\IF{$candidate \cap tree = \emptyset $}
\STATE{$tree.add(candidate)$}
\ENDIF
\ENDFOR
\STATE{$result = tree.toList()$}
\RETURN $result$
\end{algorithmic}
\end{algorithm}

\begin{theorem}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in
$\max (O(|p|*|t|*|v|), O(|t|* \log^2 |t| v))$ time with $O(|t| * v * \log {|t| * v })$ space when $|p|<|t|$ where $p$ is pattern, $t$ is text and $v$ is denominator of normalized mismatch score for semi-local sequence alignment
$w_{normalized} = (1,\frac{\mu}{v},0)$ assuming we are storing solution matrix implicitly.

\emph{First phase}.
As shown in section \ref{section:preliminaries} the time complexity 
of solving $semi-local sa$ is $O(|p|*|t|*|v|)$.
The space complexity of storing monge matrix of semi-local solution is
$O(|t| * v * \log {|t| * v })$ at most due to fact that $v-subbistochastic matrix$ has at most $v$ non-zeros in each row and upon these $v * |t|$ points we 
build two dimensional range tree data structure with $|t| * v * \log {|t| * v }$ nodes that have report range sum queries in $O(\log^2 |t| v)$ time.

\emph{Second phase}.
$SMAWK$ algorithm requires $O(|t|*q)$ time where $q$ stands for time complexity of  random access of monge matrix.
Thus, the  total time complexity of line 3 is $O(|t|* \log^2 |t| v)$ .
Filtering and sorting have at most $O(|t|)$ and $O(|t|*log|t|)$ time complexity.
In Line 6 simple intialization of interval tree is perfomed that requires $O(1)$.

\emph{Third phase}
$colmax$ array has as worst case $O(|t|)$ elements when filtering does not eliminate any substrings.
Thus, adding to interval tree (both operation at most require $O(\log |t|)$ time) as well as intersection in (Lines 8-9) will be perfomed at most $O(|t|)$.
Thus, the total complexity of last phase is $O(|t|* \log t)$.

As we see, the third  phase is dominated by the second phase in terms of running time and second phase is dominated by the space complexity of third phase. 
Thereby,the total time and space complexity is $\max (O(|p|*|t|*|v|), O(|t|* \log^2 |t| v))$ and $O(|t| * v * \log {|t| * v })$  respectively.
 

\end{theorem}


\begin{corollary}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in 
$\max ( O(|p| * |t|), O(|t| * \log |t|))$ when $v = O(1)$.

When $v = O(1)$ we will use simple range tree for orthogonal range queries with  $O(log|t|)$ query time.

\end{corollary}

\begin{corollary}
Algorithm \ref{alg:appximateMatchingMax} could  be solved in 
$O(|p| * |t|)$.

When amount of clones is relatively small and threshold value is set high  then after filtering out $t$ intervals (Line 4) sorting is perfomed on s small set of elements.
Thus, this part is dominated by calculating semi-local sa solution.
\end{corollary}




\begin{theorem}
Algorithm \ref{alg:appximateMatchingGreedy} could  be solved in 
$\max ( O(|p| * |t| * v), O(|t| * \log |t|))$ time with $ O(|t| \log |t|)$ space when $|p|<|t|$ where $p$ is pattern, $t$ is text and $v$ is denominator of normalized mismatch score for semi-local sequence alignment
$w_{normalized} = (1,\frac{\mu}{v},0)$.

On the first phase of alg

The first phase of algorithm requires $O(|p| * |t| * v)$ with $O(|t| * v)$ additional space for stroring monge matrix implicitly.
We denote this matrix, specifically it's lower-left quadrant that refers to
string-substring solution as $M$ with size $|t| \times |t|$.


  Theorema 3.4
First, note that 

Building structure for rmq queries for staircase matrix requires 
Theorem 5.8. Given an n Ã— n partial Monge matrix M, a data structure of size O(n) can be con-
structed in O(n logn) time to answer submatrix maximum queries in O(log logn) time.
   

\red{Proof it}
\begin{displaymath}
    D = \diag(d_1,\dots,d_n)
  \end{displaymath}
\end{theorem}


\begin{corollary}
Algorithm \ref{alg:appximateMatchingGreedy} could  be solved in 
$\max ( O(|p| * |t|), O(|t| * \log |t|))$ when $v = O(1)$.

\end{corollary}




  

%Given some rope $t$ and small rope $p$ you need to make cuts to form small ropes $t_{i_{1},j_{1}},t_{i_{2},j_{2}}...,t_{i_{k},j_{k}}$ for some $k$ and select some of them that very similiar to  rope $p$ i.e have high similiarity score.
%For that, we would consider constarint that each select of $t_{k} = t_{i_{k},j_{k}}$ should be made greedy i.e   $t_{k}$ it has the highest similiarity score against $p$ over all possible choices of      

 
%The following interpretation can be applied.
%Given text interval $t_{i}$   