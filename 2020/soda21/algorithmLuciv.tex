\section{Algorithm for near duplicate detection}
\label{section:luciv}

We now describe an improved version of Luciv et.al. algorithm \cite{luciv2019interactive} by utilizing a \emph{semi-local sa} solution.
Then we present proof that improved version preserves completnesess property.
It is achieved by imitating all phases of the algorithm. 
 

\subsection{Algorithm description}

The algorithm comprises three phases as in \cite{luciv2019interactive}.
At phase one (Lines 1-3) semi-local sa problem is solved for the pattern $p$ against whole text $t$.
This solution provides access to the string-substring matrix $H^{str-sub}_{p,t}$ which allows performing fast queries of \emph{sa} score for pattern $p$ against every substring of text $t$.
We apply implicitly transposition and inverse operation on $H^{str-sub}_{p,t}$:

\begin{equation}
	M[j,i]:= -H^{str-sub}_{p,t}[i,j]
\end{equation}
Note that, inverse operataion preserves (\emph{anti}) \emph{Monge} property whereas inverse operation make \emph{anti Monge} matrix \emph{Monge} and vice versa. 
So, matrix $M$ is \emph{Monge} matrix.

The second phase consist of several steps (Lines 4-6).
First, we want to obtain for each prefix of the text $t$ a longest suffix that have a highest similarity with given pattern $p$ with following constarint.
The lengths of obtained suffixies should be in $|p|*k..\frac{|p|}{k}$ interval where $k \in [\frac{1}{\sqrt{3}},1]$.
It could be done in several way.
For example, direct pass through diagonal with width $w:= \frac{|p|}{k} - |p|*k = |p|(\frac{1}{k} - k)$ in $H^{str-sub}_{p,t}$ (see fig) or in $M$ (see fig).
The other approach is following.
Note that in  $M$ is \emph{Monge matrix} and  indices is swapped.
It allows us to descry this diagonal as approximately $|t|$ square windows of size $wxw$ i.e a sliding window of step 1 that goes diagonally.
Due to lenght constraint we only interesting in elements that lies in main diagonal and below it.
Each of this $W:=wxw$ matrix is \emph{Monge matrix} by definition.
This implies that $W$ also totally monotone.
If we set to $+\inf$ that lies above diagonal that matrix will remain totally monotone.
Thus, we can apply \emph{SMAWK} algorithm to this matrix to find leftmost element that has minimum in a given row with corresponding column position.
For our case leftmost means that for each prefix algorithm will detect longest suffix (remember that $M$ is transposed $H^{str-sub}_{p,t}$ ).

Second step, it is simply one way pass through these suffixes with sliding window  of size $\frac{|p|}{t}$ to find for each window most similar suffix with the longest length. Then resulting set is filtered out that remaining suffixes have score greater or equal to given theshold $-k_{di}$. 

The third phase is same as in \cite{luciv2019interactive} (Lines 8-12).  



%At the second phase text $t$ is scanning with a sliding window of length $L_{w}$ with step 1.
%First, it checks that given substring $w$ that of a maximum possible size of $L_{w}$ have score that is higher or equal to a given threshold (Line 4).
%If no, then this interval will not further be proceeded (Line 5) else this interval will be processed as follows.
%First, for each prefix of text $t$ it finds suffix that has the highest alignment score with the maximal length among all suffixes with that score. 
%It corresponds to the searching row position for each column in string-substring matrix with associated alignment score. 
%Second, among these suffixes, one is selected with the highest score.
%If several suffixes have the same score the one with maximal length is selected (Line 8).
%Then if selected suffix has score higher than the threshold, then it is added to set $W_2$.

%The third phase is the same as in \cite{luciv2019interactive}. 
%More precisely, on the third phrase, set $W_{2}$ is filtered out in a such way that only non-intersected intervals are left.
%It is simply the sorting of set $W_{3}$ by starts of intervals with following one way passage with filtering.  


\begin{algorithm}[H]
\caption{PATTERN BASED NEAR DUPLICATE
SEARCH ALGORITHM VIA SEMI-LOCAL SA}
\label{alg:patternMathing1}
Input: pattern $p$, text $t$, similiarity measure $k \in  [ \frac{1}{\sqrt{3}} ,1  ]$\\
Output: Set of non-intersected clones of pattern $p$ in text $t$
\begin{equation}
    k_{di}=|p|*(\frac{1}{k}+1)(1-k^2)
\end{equation}
\begin{equation}
 L_{w} = \frac{|p|} {k}
\end{equation}
\begin{equation}
  w = |p|(\frac{1}{k} - k)
\end{equation}
Pseudocode:
\begin{algorithmic}[1]
\STATE{$W = semilocalsa(p,t)$}
\COMMENT{1st phase}
\STATE{$H^{str-sub}_{p,t} = semilocalsa(p,t).stringSubstringMatrix$}
\STATE{$M[j,i] = -H^{str-sub}_{p,t}[i,j]  $}
\STATE{$sufixes = processDiagonal(M,L)$}
\COMMENT{2d phase}
\STATE{$W_2 = SuffixMaxForEachWindow(sufixes,L_{w})$}
\STATE{$filter(W_2,k_{di})$}
\STATE{ $W_3 = UNIQUE(W_2)$}
\COMMENT{3rd phase unchanged}
\FOR{$w \in W_3$}
\IF{$\exists w^{'} \in W_3:w \subset w^{'} $}
\STATE{ $remove$ $w$ $from$ $W_3$}
\ENDIF
\ENDFOR
\RETURN $W_3$

\end{algorithmic}
\end{algorithm}


\begin{theorem}
Algorithm \ref{alg:patternMathing1} could  be solved in $ O(|p| * |t| )$ where $p$ is pattern, $t$ is text.

\red{Proof it}
\begin{displaymath}
    D = \diag(d_1,\dots,d_n)
  \end{displaymath}
\end{theorem}

\begin{theorem}
Algorithm \ref{alg:patternMathing1} preserves completnesses property of algorithm \cite{luciv2019interactive}.

\red{Proof it}
\begin{displaymath}
    D = \diag(d_1,\dots,d_n)
  \end{displaymath}
\end{theorem}
